# Java SE



### 基本数据类型

-   整型：byte，short，int，long。
-   浮点型：float，double
-   字符型：char
-   布尔型：boolean

>   switch语句中可以跟byte，short，int，char，string



### 浮点数

double浮点数运算存在精度丢失的问题。

通常使用BigDecimal处理浮点数运算。

```java
// 常用构建方法
BigDecimal.valueOf();
new BigDecimal(String val);
// 比较大小
BigDecimal.equals(); // 会对值和精度同时比较
BigDecimal.compareTo();// 只会对值进行比较
add(); //相加
subtract(); //相减
multiply(); // 相乘
divide(); //相除
```





### 引用类型

-   强引用（Strong Reference）：Java 中正常 new 的对象，或者通过反射手段创建的对象都属于强引用，即使进行了多次的GC回收，即使JVM真的已经不够用了，即使 JVM 最终不得已抛出了 OOM 错误，那么该引用继续抢占；

-   软引用（Soft Reference）:当内存空间不足时，可以回收此内存空间。如果充足则不回收，可以用其完成缓存的一些处理操作开发。

    >   缓存：保证数据更快的操作（读取）。是不重要的数据。可以作为牺牲来释放空间。

-   弱引用（Weak Reference）：不管内存是否紧张，只要一出现GC处理，则立即回收。

-   幽灵引用（Phantom Reference）：和没有引用是一样的，在对象被收集器回收时收到一个系统通知。



#### 值传递和引用传递

程序设计语言将实参传递给方法（或函数）的方式分为两种：

-   **值传递**：方法接收的是实参值的拷贝，会创建副本。
    -   如果参数是基本类型的话，传递的就是基本类型值的拷贝，创建副本，不会影响原来的值。
    -   如果参数是引用类型的话，传递的就是实参所引用的对象在堆内存中地址的拷贝，同时会创建副本。

-   **引用传递**：方法接收的是实参所指向的对象在堆内存中的地址，不会创建副本，对形参的修改将会影响到实参。

>   Java中只有值传递。（ps:对实参对象属性的修改，还是会影响到原有对象，因为值传递只针对实参本身进行副本拷贝，而不会对参数属性进行拷贝）
>
>   C++，Pascal中包含两种传递方式。



为什么Java不采用引用传递？

1.  安全问题，方法内部对值进行的操作，对于调用者都是未知的。
2.  引用传递学习成本高，一不留意就会产生问题。



#### 包装类型

-   Integer是int的包装类，int则是java的一种基本数据类型 
-   Integer变量必须实例化后才能使用，而int变量不需要 
-   Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 
-   Integer的默认值是null，int的默认值是0

装箱：基本数据类型转换为包装类型(底层通过valueof方法进行转换)

拆箱：包装类型转换为基本数据类型(底层通过intValue方法进行转换)



### Java 关键字

#### final

-   修饰变量:一次赋值，不能在修改。
-   修饰方法:当前方法不能被重写。
-   修饰类:当前类不能被继承。(java.lang包下的类基本都是被final修饰)



**final、finally、finallize有何区别?**

-   final修饰符（关键字）。
-   finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。
-   finalize是方法名。java允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。



#### static

-   修饰方法，变量，代码块时，这些都可以通过，类名.调用，并且会优先初始化。
-   好处：节省内存，只用初始化一次即可。速度快，静态属性优先加载。
-   使用场景：如果一个类的某个属性被所有实例所共享那么这个属性适合用static修饰。



#### super、this

-   this:指的是当前类对象

-   super:当前对象中父对象的引用

    >   这两个关键字不能同时出现在一个构造函数中。



#### 权限修饰符

-   private（私有的）：本类调用，非本类需要通过get/set调用和修改。
-   public（公开的）：当前项目都可以调用。
-   protected（受保护的）：本包都可以调用，非本包的子类内部可以访问。
-   default：默认的，本包都可以访问。



#### throw、throws

抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常

1.   系统自动抛异常，当程序出现一些逻辑错误，主义错误或者类型转换错误时，系统会自动抛异常。
2.   throw，throw是有语句抛出一个异常，一般是在代码块的内部，当程序出现逻辑错误时由程序员主动抛出某种特定类型的异常。通过throw抛异常会创建一个异常对象。（ClassFormatException,ConcurrentModificationException,NullPointerException,DateTimeException）
3.   throws，在方法参数列表后，throws后可以跟着多个异常名，表示向调用该类的位置抛出异常，不在该类解决。

>   throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，执行throw则一定抛出了某种异常。







### 抽象类、接口

**语法上的区别**：

1.  抽象类可以有构造方法，接口中不能有构造方法。
2.  抽象类中可以有普通成员变量，接口中没有普通成员变量
3.  抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法（但在Java8之后加入了**默认方法**和**静态方法**，可以使用接口来定义模版类）。
4.  抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的。
5.  抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是常量。
6.  一个类可以实现多个接口，但只能继承一个抽象类。

**应用上的区别**：接口一般用于对模块系统架构设计，对模块之间方法的调用进行解耦。抽象类在代码实现方面发挥作用，可以实现代码的重写复用。



### 重载与重写

-   方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
-   重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载，重载对返回类型没有特殊的要求，不能根据返回类型进行区分。
-   重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。



### 代码块

-   静态代码块，带有static关键字，跟成员属性同一级，随着类的加载而执行，只执行一次。
-   局部代码块，在方法体里的代码块，方法被调用就会执行。
-   构造代码块，跟成员属性同一级，当前类对象每创建一次就会执行一次，优先于构造方法。



### 面向对象

1.   **封装**，隐藏内部实现细节，对外暴露可访问的方法。get、set方法访问类中的成员属性。
2.   **继承**，一个子类只能继承一个父类，子类继承父类的属性和方法，不能继承构造器和私有属性，子类的构造器会默认调用父类的构造器。提高了代码的复用性。
3.   **多态**
     1.   向下转型：父类引用指向子类对象，此时父类引用不能调用子类独有的成员属性。
     2.   向上转型：子类引用指向父类对象。



### 序列化和反序列化

在Java这种面向对象编程语言中，序列化都是对象Object，c++中序列化的都是数据结构。

**序列化**：将数据结构或对象转换成二进制字节流的过程。

**反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或对象的过程。

**应用场景**：

1.  对象在进行网络传输之前需要先被序列化，接收到序列化的对象之后需要在进行反序列化。
2.  将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化。
3.  将对象存储到数据库。
4.  将对象存储到内存。

序列化的主要目的是通过网络传输对象或者将对象存储到文件系统、数据库、内存中。

序列化协议在TCP/ip协议中各个层级都会涉及到。

>   @Transient：修饰变量，当前变量不会进行序列化操作
>
>   比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议； JSON 和 XML 这种属于文本类序列化方式



### I/O

InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流。

OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。

**I/O为什么要分字节流和字符流？**

-   字符流是由Java虚拟机将字节码转换得到的，这个过程是比较耗时的。
-   使用字节流的过程中很容易出现乱码问题。



### 反射

在运行时分析类以及执行类中方法的手段。

**优缺点**：

**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。

**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

**获取class对象的四种方法**

```java
Class clazz = object.class;// 类名
Class clazz = object.getClass();// Object的静态方法
Class clazz = Class.forName("");// Class的静态方法
Class clazz = ClassLoader.getSystemClassLoader().loadClass("");// 类加载器
```

反射基本方法/功能

```java
ClassLoader classLoader = aClass.getClassLoader();// 获取当前类的类加载器
Constructor<?>[] constructors = aClass.getConstructors();// 获取当类的构造器
Field[] declaredFields = aClass.getDeclaredFields();// 获取当前类中所有参数
boolean annotation = aClass.isAnnotation();// 判断当前类上是否包含注解
Method[] methods = aClass.getMethods();// 获取当前类中公开的（public修饰的）方法
```



### 代理

**静态代理**：实现并注入被代理类，在代理类的对应方法中调用目标类中的对应方法，就可以在目标方法前后做一些自己想做的事情。在`编译时`就将接口、实现类、代理类这些变成了一个个实际的class文件；（创建一个被代理类的实现，在实现类里做增强。）

**动态代理**：在`运行时`动态生成类字节码，并加载到jvm中。

>   SpringAOP：如果目标对象实现了接口，默认采用JDK动态代理，否则使用CGLIB动态代理。

两种实现方式：

JDK动态代理：核心是Proxy类、InvocationHandler接口；只能代理接口的实现类（因为在通过 Proxy 类创建代理类时需要传入被代理类所实现的所有接口列表）。

JDK动态代理流程：

```markdown
1.通过Proxy类的newProxyInstance()创建代理对象。
2.调用代理对象的原生方法时，实际会调用到InvocationHandler接口的invoke()方法，我们可以在invoke()中做增强操作。
```

CGLIB动态代理：核心是MethodInterceptor接口和Enhancer类；主要针对子类。

CGLIB动态代理流程：

```markdown
1.定义被代理类
2.自定义代理类实现MethodInterceptor并重写intercept方法，intercept用于自定义增强操作，跟jdk动态代理invoke类似。
3.通过Enhancer类的create()创建代理类。
```

两种实现方式对比：

1.jdk动态代理只能代理实现了接口的类，cglib可以代理未实现任何接口的类，cglib主要是通过继承子类的形式实现代理，不能代理声明为final类和方法。

2.jdk动态代理效率最高。



### 元注解

`元注解`的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。

1.   `@Target` 修饰的对象范围

@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标

2.   `@Retention` 定义注解的生命周期

取值（RetentionPoicy）由：

-   SOURCE:在源文件中有效（即源文件保留）
-   CLASS:在 class 文件中有效（即 class 保留）
-   RUNTIME:在运行时有效（即运行时保留）

3.   `@Documented` 描述-javadoc

@Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。

4.   `@Inherited` 阐述了某个被标注的类型是被继承的

@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。





### 高频问题



#### ==和equals（）的区别？

1.对于 `==`，比较的是值是否相等如果作用于基本数据类型的变量，则直接比较其存储的值是否相等，如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。
2.equals()方法不能作用于基本数据类型的变量，equals()方法存在于Object类中，所以说所有类中的equals()方法都继承自Object类，在没有重写equals()方法的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址，不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。

>   因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。
>
>   JDK 1.8中，str.intern() 会复制字符串常量池的内存地址来赋值给自定义引用，两个字符串做==比较的话结果为true





#### String、Stringbuffer、StringBuilder的区别以及使用场景

1.   String声明的是不可变的对象(final修饰的),每次操作都会生成新的string对象,然后将指针指向新的string对象。

>   为什么不可变？
>
>   1.   防止在对同一个数据造成不可避免的修改
>
>   2.   可以通过常量池减少对象创建的开销
>
>   Java 8 及之前的版本，String 一直是用 char[] 存储。在 Java 9 之后，String 的实现改用 byte[] 数组存储字符串，节省了空间。

2.   而StringBuffer,StringBuilder可以在原有对象的基础上进行操作,若是在经常改变字符串内容的情况下最好不要使用string

-   StringBuffer是线程安全的
-   StringBuilder是非线程安全的,但stringbuilder的性能却高于stringbuffer
-   单线程环境下推荐使用stringbuilder,多线程环境下推荐使用stringbuffer



#### hashCode()和equals()方法有何重要性？

-   Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。
-   如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此可能会被集合认为是相等的。
-   而且，这两个方法也用来发现重复元素，所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。



### 数据结构

### JDK新特性

#### 1.jdk8新特性

**1.Lambda** **表达式** 

Lambda 允许把函数作为一个方法的参数。 

![img](./img/clip_image002.jpg)

**2.方法引用** 

方法引用允许直接引用已有 Java 类或对象的方法或构造方法。

上例中我们将 System.out::println 方法作为静态方法来引用。

**3.函数式接口** 

有且仅有一个抽象方法的接口叫做函数式接口，函数式接口可以被隐式转换为 Lambda 表达式。通常函数式接口 

上会添加@FunctionalInterface 注解。 

**4.接口允许定义默认方法和静态方法** 

从 JDK8 开始，允许接口中存在一个或多个默认非抽象方法和静态方法。

**5.Stream API** 

```
可以进行链式编程，里面的特殊的方法会结束这个链式，
foreach（遍历），count（聚合）；
skip（跳过前几个），limit（取用前几个），map（映射），filter（过滤），concat（组合）
流的特性：支持并行流与顺序流，
并行流：多个线程同时运行（.parallel()）
顺序流：使用主线程，单线程（.sequential()）
```

**6.日期/时间类改进** 

之前的 JDK 自带的日期处理类非常不方便，我们处理的时候经常是使用的第三方工具包，比如 commons-lang 包等。不过 JDK8 出现之后这个改观了很多，比如日期时间的创建、比较、调整、格式化、时间间隔等。这些类都在 java.time 包下，LocalDate/LocalTime/LocalDateTime。

**7.Optional** **类** 

Optional 类是一个可以为 null 的容器对象。如果值存在则 isPresent()方法会返回 true，调用 get()方法会返回该对象。 

**8.Java8 Base64** **实现** 

Java 8 内置了 Base64 编码的编码器和解码器。

**9.多线程处理**

```java
CompletableFuture<T> // 函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力；
CompletableFuture.get() // 阻塞调用
CompletableFuture.join() // fork线程循环监听任务结果，并返回，可能出现结果不存在情况
```

>   Future是Java中异步思想实现，可以异步执行任务，再获取执行结果。
>
>   Future在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用

**10.多重注解**

#### 2.Java 9 新特性

1.  G1 成为默认的垃圾收集器
2.  接口私有化方法
3.  响应式流 Flow
4.  变量句柄

#### 3.Java11新特性

1.HttpClient标准化，支持异步非阻塞（CompleteableFuture）。

2.类库增强，String、Optional。

3.ZGC垃圾收集器。

4.局部变量类型推断支持var（java10引入var关键字）

#### 4.Java17新特性

1.switch添加自动类型转换功能。

2.Vector API 在16版本提出，表达向量计算的API。

3.seald permits 密封类。