# JVM

## 1.JVM内存空间

> JVM运行时所管理的内存

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)



### 1.程序计数器

作用：**记住下一条jvm指令的执行地址**，当前指令执行同时会将下条jvm命令的执行内置放入程序计数器中。当前指令执行完毕后，解释器会通过程序计数器中的地址继续执行指令。

线程是占用CPU执行的基本单位，而CPU一般是使用时间片轮转方式让线程轮询占用的，所以当前线程CPU时间片用完后，要让出CPU，等下次轮到自己的时候再执行。程序计数器就是为了**记录该线程让出CPU时的执行地址**的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行。

特点：

- 线程私有
- jvm中唯一没有内存泄漏的风险的区域

```markdown
通过改变这个计数器的值来选取下一条需要执行指令的字节码 指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成
```



### 2.虚拟机栈

栈：线程运行时的内存空间。

栈帧：方法运行时的内存空间。

```markdown
Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程

//命令
-Xss size
指定栈内存大小

```

> 活动栈帧：栈最顶部的栈帧



问题：

1. 方法内的局部变量是否线程安全？

    - 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的。

    - 如果局部变量引用了变量，并逃离方法的作用范围，它是线程不安全的

2. 栈内存溢出（<font color='red'>***java.lang.StackOverflowError***</font>）

    - 栈帧过多导致栈内存溢出
    - 栈帧过大导致内存溢出
    
3. 线程运行诊断

    - CPU占用过多

    ```markdown
    诊断步骤：
    1.通过top命令查询进程占用
    2.ps命令定位线程占用
    3.jstack id（根据线程id找到有问题的线程，定位到源代码）
    ```

    ```shell
    jstack 进程id(pid)  # 控制台输出指定进程的信息
    jstack  进程id >文件     #打印堆栈信息到文件中 
    jstack -l  进程id    #除堆栈外，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况  
    ```
    
    >   注意：
    >
    >   1.   jstack只能分析JVM虚拟机开启的进程
    >
    >   2.   jstack生成快照中，tid 是java中为这个线程的id，nid 是这个线程对应的操作系统本地线程id，每一个java线程都有一个对应的操作系统线程，且它们都是通过16进制表示的
    
    - 程序运行长时间没有结果
    
    ```markdown
    诊断步骤同上
    ```
    
    





### 3.本地方法栈

```markdown
本地方法栈则为虚拟机使用到的 Native 方法服务
```

### 4.java堆

```markdown
JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)
```

### 5.方法区

```markdown
存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
```

### 运行时常量池

```markdown
属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern())都可以将常量放入池中
```

### 直接内存

```markdown
非虚拟机运行时数据区的部分，是java虚拟机向操作系统申请的一片内存空间
```

## 2.JVM对象

> 在JVM中，对象在内存中的布局分为三块区域：对象头，实例数据，对齐填充。

### 2.1对象头（Header）

```markdown
包含两部分
	1.第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等这部分数据的长度在32位和64位的虚拟机中分别为32位和64位。官方称为Mark Word。
	2.第二部分是类型指针，就是指向对象数据类型的指针，虚拟机通过这个指针确定这个对象是哪个类的实例，如果是数组对象的话，还会有一个额外的部分存储数组长度
```

### 2.2实例变量

```markdown
存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还会包含数组的长度，这部分内存按4字节对齐
```

### 2.3对齐填充

```markdown
由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。
```

JVM判断对象是否死亡的方法

1.引用计数法

```markdown
即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象
```

2.可达性分析法

```markdown
通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收
```

> - 虚拟机栈(栈帧中的本地变量表)中引用的对象
> - 方法区中类静态属性引用的对象
> - 方法区中常量引用的对象
> - 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象

## 引用类型

```markdown
1. 强引用
		类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。
2. 软引用
		SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。
3. 弱引用
		WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。
4. 虚引用
		PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
```

## JAVA堆的内存模型

使用分代收集算法根据对象的生命周期将内存划分为老年代和新生代

```markdown
1. 新生代GC (Minor GC)主要使用复制算法进行垃圾回收
		占用堆内存的三分之一
		1.Eden区
			占用新生代的十分之八，java新对象的出生地，如果新创建的对象占用内存很大，就会直接分配到老年代中，当Eden区内存不够时会触发Minor GCd对新生代区进行一次垃圾回收
		2.From Survivor区
			占用新生代的十分之一，保存上一次GC的幸存者，来作为这一次GC的被扫描者
		3.To Survivor区
			保留一个MinorGC过程中的幸存者
2. 老年代GC主要使用标记整理算法
		MajorGC
```



## gc垃圾回收算法

标记-清除算法：标记需要被清除对象，然后进行清除回收。

缺点：效率不高，无法清除垃圾碎片。
复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1

缺点：内存使用率不高，只有原来的一半，消耗内存。
标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代（默认是1:2），新生代基本采用复制算法，老年代采用标记整理算法。

## gc垃圾收集器

#### 串行（serial）

为单线程设计且只使用一个线程进行垃圾回收，会暂停所有用户线程（STW [stop the word]）。

1.对于单核CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率。serial垃圾收集器是java虚拟机运行在client模式下默认的新生代垃圾收集器。

```properties
命令：-XX:+UseSerialGC
#开启后，新生代采用serial收集器，老年代采用serial old收集器.新生代和老年代都是采用串行收集器，新生代采用复制算法，老年代采用标记-整理算法
```





#### 并行（Parallel）

多个垃圾线程并行收集，此时用户线程是暂停的。停顿时间短。

1.串行垃圾收集器的多线程版本，常见的应用场景就是配合老年代的CMS工作。是很多jvm运行在server模式下的新生代的默认垃圾收集器。

```properties
命令：-XX:+UseParNewGC
#开启后，只会将新生代的收集器转换为Parallel收集器，不会影响老年代。会采用Parallel+serial old组合。新生代采用复制算法，老年代标记-整理算法。（不推荐使用）

命令：-XX:+UseParallelGC 或者 -XX:+UseParallelOldGC
#开启后，会将新生代和老年代的收集器都转换为并行收集器。采用Parallel+Parallel old组合，新生代采用复制算法，老年代采用标记-整理算法。(JDK1.8默认采用的组合)
```



#### 并发（CMS）

用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程。适用于对响应时间有要求的场景。

收集步骤：
1.初始标记

标记下gc root能直接关联的对象，速度快，但需要暂停用户线程。

2.并发标记

进行GCroot跟踪过程，和用户线程一起工作，不需要暂停线程。主要标记过程，标记全部对象。

3.重新标记

为了修正在并发标记期间，因为用户线程继续运行导致的一部分对象变动，需要暂停工作线程进行修正。





```
命令：-XX:+UseConcMarkSweepGC 会自动将-XX:+UseParNewGC打开
开启后会采用ParNew+CMS+Serial old组合。serial old是cms出错后的后备收集器。新生代采用复制，老年代采用标记-清除。
```



#### G1

将堆内存分割为不同的区域然后并发的对其进行垃圾回收。





1.Serial/Serial Old

　　Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是标记-整理算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。

2.ParNew

　　ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。

3.Parallel Scavenge

　　Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。

4.Parallel Old

　　Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和标记整理算法。

5.CMS

　　CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是标记清除算法。

6.G1

　　G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。

G1收集器有以下特点：

(1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。

(2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。

(3). 空间整合。基于标记 - 整理算法，无内存碎片产生。

(4). 可预测的停顿。指定在一个毫秒级的消耗在垃圾收集上的时间。

   在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。











jvm基本命令

```
jps:查询当前机器中java程序进程
jinfo:查询jvm参数的运行情况
```







## 调优参数



#### 1.参数类型

```properties
-XX参数：

1.boolean类型：（-：关闭，+：开启）
-XX:-PrintGCDetails:打印gc日志信息

2.k-v类型（-XX:参数名=值）
#元空间内存大小
-XX:MetaspaceSize=1000m
#老年代年龄
-XX:MaxTenuringThreshold=15
```



#### 2.常用参数

```properties
#堆初始空间大小（默认为物理内存的1/64）
-Xms: == -XX:InitialHeapSize
#堆内存空间最大值（默认为物理内存的1/4）
-Xmx: == -XX:MaxHeapSize
-Xmn:新生代内存大小
#设置单个线程的栈大小，默认0.5m-1m
-Xss:栈空间大小 == -XX:ThreadStackSize

#设置元空间内存大小，默认内存较小
-XX:MetaspaceSize=1024

#打印gc收集日志
-XX:+PrintGCDetails
#设置新生代内存占比
-XX:SurvivorRatio=8,Eden:S0:S1=8:1:1
#配置新生代和老年代的占比
-XX:NewRatio=2（默认老年代占比为2，新生代占比1/3）
#进入老年代年龄
-XX:MaxTenuringThreshold=15
```



#### 3.查询当前jvm默认参数命令

```properties
#查询某个参数是否开启:
jinfo -flag PrintGCDetails pid;

#打印java运行时的初始化参数
java -XX:+PrintFlagsInitial

#打印修改过后的参数
java -XX:+PrintFlagsFinal -version

#打印当前jvm默认的垃圾回收器
java -XX:+PrintCommandLineFlags -version

:=修饰的参数：更新过的参数；
```



## oom

```properties
1.StackOverflowError
#递归调用层级太多，导致栈内存不够
2.OutOfMemoryError:Java heap space
#堆内存空间不够
3.OutOfMemoryError:GC overhead limit exceeded
#gc回收时间过长，超过98%的时间用来做gc并且回收了不到2%的堆内存
4.OutOfMemoryError:Direct buffer memory
#nio程序中使用buffer来进行io，可以去分配堆外内存也就是本地内存，此时产生的对象不会进行gc，当不断进行内存分配，如果本地内存使用完毕就会导致程序直接崩溃。
5.OutOfMemoryError:unable to create new native thread
#当前应用创建太多线程，超过系统承载极限
6.OutOfMemoryError:Metaspace
#元空间（方法区）内存不足
```





