# JUC

## 1.volatile

```markdown
1. 概念:
		一种java虚拟机提供的轻量级的同步机制
2. 特性:
		a.保证可见性（通过内存屏障保证可见性）
		b.不保证原子性
		c.禁止指令重排（保证有序性）
		
volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序的现象。

3. 适用场景（在哪些地方用过volatile）：
	    1.单例模式，通过DCL机制
	    2.读写锁，手写缓存
	    3.CAS底层的juc也用volatile
```



> 1.doouble check lock双端检锁机制，底层变量使用volatile修饰，对象创建时进行synchronized加锁
>
> 2.dcl机制存在线程安全问题，当对象初始化时，由于指令重排可能会导致对象未初始化时，就获取实例对象来指定内存地址，导致异常报错



### 1.1 内存屏障（Memory Barrier）

```markdown
概念：内存栅栏，是一个CPU指令
作用：
	1.保证特定操作的执行顺序
	2.保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）

工作原理：
	由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另一个作用就强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最性版本。
	
	1.对Volatile变量进行写操作时：
		会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷性回到主内存。
	2. 对Volatile变量进行读操作时：
		会在读操作前加入一条load屏障指令，从主内存中读取共享变量。
```

> 指令重排只会保证串行语句的一致性

**问题**

1.  工作内存和主内存同步延迟现象导致的可见性问题

    可以使用synchronize或volatile关键字解决，它们都可以使<font color='red'>一个线程修改后的变量立即对其他线程可见</font>。

2.  对于指令重排导致的可见性问题和有序性问题。

    可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。





















## 2.JMM(JAVA内存模型)

本身是一种抽象的概念并不真实存在，描述的是一种规则或者是规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。

```markdown
1. 特性：
	1.可见性
		当某个线程修改了其内存中共享变量的值时，其他线程能立刻感知到其值的变化
	2.原子性
		一个操作是不可中断，即使有多个线程执行，一个操作开始也不会受其他线程影响，即可以理解为线程的最小执行单元，不可被分割
	3.有序性
		程序按一定规则进行顺序的执行，期间会进行编译器优化重排、指令重排、内存重排等，执行规则遵循as-if-serial语义规则和happens-before 原则
		as-if-serial语义规则：即是不管怎么重排，最后的执行结果是不能改变的。
	
2. 规定：
		1.线程解锁前，必须把共享变量的值刷新回主内存。
		2.线程加锁前，必须读取主内存的最新值到自己的工作内存。
		3.加锁解锁是同一把锁。
3. 工作流程：
		由于JVM运行程序的实体是线程，每个线程创建jvm都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而java内存模型中年规定所有变量都存储在主内存，主内存是共享内存，所有的线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量协会主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
```

###  2.1 Happens-before原则

```markdown
1. 定义：
        1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 
        2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法
2. 规则：
        1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
        2.锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
        3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
        4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
        5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
        6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
        7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
        8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；
```





## 3.CAS机制(比较并交换)

```markdown
1. 应用场景：
        整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的
        ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。可以说CAS是整个JUC的基石。
2. 概念
		物理内存中的值：主内存值
		期望值：工作内存值
		值偏移量：值的地址
		当前线程会携带自身工作内存中的值（主内存值的快照）和值偏移量进入方法，通过getIntVolatile方法取出主内存的值,调用compareAndSwapInt与主内存中值进行比较，如果相等会进行修改操作，不相等就会进行do-while循环，重新获取工作内存的资源。
3. 工作原理
		调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令，是一种完全依赖于硬件的功能，通过它实现了原子操作，是由多个指令组成的，用于完成某个功能的一个过程，并且这些指令的执行必须是连续的，在执行过程中不允许中断，不会造成数据不一致的问题。
4. 缺点
		1.循环时间长，开销大
			如果CAS失败，会一直进行尝试，会一直占用CPU带来很大的开销。
		2.只能保证一个变量的原子性，对于多个共享变量操作，要使用加锁来保证原子性。
		3.ABA问题
			通过AtimicStampedReference<V>原子类解决，原子类+时间戳（版本号）;
```

> ABA问题描述：t1和t2两个线程，同时改变一个共享变量A，此时两个线程会将主内存中的A值复制到自己的工作内存中，两个线程由于执行时间的原因，t2先将A改为B，然后又将B改为A，t1再去改变内存中的A值。但它无法知道这个值已经被改变过了，尽管t1的CAS操作成功，但并不代表这个过程没有问题。

### 3.1 Unsafe

```markdown
1. 全称：
		sun.misc.Unsafe
2. 作用：
		Java无法直接访问底层操作系统，而是通过本地（native）方法来访问,而Unsafe为我们提供了类似C++手动管理底层操作系统内存的能力
```





## 4.集合

 ConcurrentModificationException 并发修改异常

```markdown
1. 导致原因
		并发修改，导致数据不一致异常。
2. 解决方案
		a.使用Vatcor
		b.使用Collections.synchronizedList
		c.CopyOnWriteArrayList<>(写时复制)		
3. 优化建议
		 
```

> 写时复制：往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy,复制一个新的容器Object[]数组 newElements，然后往新的容器里添加容器，添加完元素之后，再将原容器的引用指向新的容器setArray(newElements);这样做的好处是可以对容器进行并发读，而不需要加锁，因为当前容器不会添加任何元素，所以copyOnWrite容器也是一种读写分离的思想，读和写不同的容器





## 5.锁

### 5.1 公平锁和非公平锁

```markdown
1. 公平锁：
		指多个线程按照申请锁的顺序来获取锁
		
2. 非公平锁：
		指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁在高并发的情况下，有可能造成优先级反转或者饥饿现象
		

3. 区别
        1.公平锁在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空或者当前线程是等待队列的第一个，就会占有锁，否则就会加入到等待队列，按照FIFO规则（先进先出）从队列中取到自己
        2.非公平锁上来就会尝试占有锁，如果尝试失败，就采用类似公平锁的方式加入等待队列
		3.非公平锁的吞吐量比公平锁大

并发包中ReentrantLock的创建可以通过指定Boolean类型的参数来得到公平锁或者是非公平锁，默认是fasle非公平
synchronized是一种非公平锁。
```

### 5.2 可重入锁（递归锁）

```markdown
1. 概念：
		1.指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码。同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
		2.也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。
2. 作用：
		避免死锁
		
ReentrantLock和Synchronized都是典型的可重入锁
```

> lock锁可以加多次，编译运行不会出错，但是加锁的次数要和解锁对应

### 5.3 自旋锁（SpinLock）

```markdown
1. 概念：
		指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。
		循环比较获取直到成功为止，没有类似wait的阻塞
2. 优缺点：
		减少线程上下文切换的消耗.
		循环会消耗CPU.
```

### 5.4独占锁（写锁）

```markdown
1. 概念
		该锁只能被一个线程所持有
		
ReentrantLock和Synchronized是独占锁
```

### 5.5共享锁（读锁）

```markdown
1. 概念
		该锁可被多个线程所持有
ReentrantReadWriteLock的读锁是共享锁，写锁是独占锁
```

### 5.6互斥锁

```

```



### 5.7乐观锁

```
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。
在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。AtomicInteger
```



### 5.8悲观锁

```
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。
数据库中的写锁就是悲观锁。
Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
```



### sychronized

```markdown
1. 实现原理：
		jvm基于进入和退出Monitor对象来实现方法的同步和代码块的同步
2. 方法
		方法的同步是隐式的，不需要通过字节码指令来进行控制，主要实现在方法调用和返回操作之中，jvm可以从方法常量池中的方法表结构中的访问标识区分一个方法是否被同步，当方法调用时，调用指令会检查访问标识是否被设置，如果被设置了，执行线程将先持有monitor对象，然后再执行方法，方法完成，释放monitor对象
3. 代码块		
		代码块同步，利用monitorenter和monitorexit这两个字节码指令分别位于同步代码块开始和结束位置，当jvm执行monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者被当前线程持有，就把锁的计数器+1，当执行exit指令时，锁的计数器-1，当计数器为0时，该锁就被释放，如果获取失败就会进行阻塞
		
1.当修饰静态方法的时候，锁的是当前类的class对象。
2.当修饰实例方法时，锁的就是当前类的实例对象。
3.当修饰代码块的时候，锁的是同步代块里的对象实例。
```



### synchronized与lock的区别

```markdown
1. Lock 是 API层面，是java5以后新出现的一个类，synchronized 是 JVM 级别的是java关键字
2. synchronized不需要用户手动释放锁对象，当synchronized代码执行完后系统会自动让线程释放对锁的占用，而lock需要手动释放锁对象，若没有主动释放锁，有可能导致死锁现象出现
3. synchronized不可中断，除非抛出异常或者正常运行完成
		1.lock可中断，设置超时方法tryLock(Long time,TimeUnit unit)，到指定时间后会获取尝试获取锁，获取不到就直接中断。
		2.lockInterruptibly()放代码块中，调用interrupt()方法可中断
3. synchronized默认是非公平锁，reentrantlock默认是非公平锁
4. synchronized不可以绑定多个条件Condition, ReentrantLock 通过 Condition 可以绑定多个条件，达到精确唤醒线程。
5. ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.
```

>   interrupt（）是给线程设置中断标志；
>
>   interrupted（）是检测中断并清除中断状态；
>
>   isInterrupted（）只检测中断。
>
>   还有重要的一点就是interrupted（）作用于当前线程，interrupt（）和isInterrupted（）作用于此线程，即代码中调用此方法的实例所代表的线程。









## 6. JUC工具包

#### a.CountDownLatch(闭锁)

```java
1. 概念：允许一个或多个线程等待其他线程完成操作。
    
2. 构造方法：
		new CountDownLatch(int count);
3. 重要方法：
    	void await(); 阻塞线程
    	void countDown(); 计数器减一
```

> 工作流程：
>  	CountDownLatch是通过一个计数器来实现的，每当一个线程完成了自己的任务后，可以调用countDown()方法让计数器-1，当计数器到达0时，调用CountDownLatch,await()方法的线程阻塞状态解除，继续执行。

#### b.CyclicBarrier(计数器)

```markdown
1. 概念：
		可循环使用的屏障，让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，屏障才会开门，所有被屏障拦截的线程才会运行工。
2. 构造方法
		new CyclicBarrier(int parties,Runnable barrierAction);线程数量，线程
3. 方法 
		int await(); 线程阻塞
```

#### c.Semaphore(信号标)

```markdown
1. 概念：
		控制线程的并发数量
2. 构造方法
		new Semaphore(int permits); 许可线程的数量
		new Semaphore(int permits,boolean fair); 公平性，为true时，使用下次线程会等待最久的线程。
3. 重要方法：
		void acquire(); 获取许可
		void release(); 释放许可
```

## 7.阻塞队列（BlockingQueue）



```markdown
1. 概念	
		在多线程领域中，所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒
		当阻塞队列是空的时候，从队列里获取元素会被阻塞
		当阻塞队列是满的时候，从队列里添加元素会被阻塞

好处：
	不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给实现好了
```

### 种类分析

```properties
ArrayBlockingQueue: 是一个基于数组结构的有界阻塞队列，此队列按照FIFO原则对元素进行排序
LinkedBlockingQueue:是一个基于链表结构的有界阻塞队列，此队列按照FIFO原则对元素进行排序，吞吐量高于ArrayBlockingQueue
LinkedTransferQueue:由链表组成的无界阻塞队列
LinkedBlockingDeque:由链表组成的双向阻塞队列
SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态
PriorityBlockingQueue:支持优先级排序的无界阻塞队列
DelayQueue:使用优先级队列实现的延迟无界阻塞队列
```

## 8.线程池

```markdown
1. 线程池做的工作主要是控制运的线程的数量，处理过程中将任务放入队列，然后
2. 特点：线程复用，控制最大并发数，管理线程
3. 好处：
		1.降低资源消耗，通过重复利用已创建的线程降低线程的创建和销毁时的资源消耗。
		2.提高响应速度，当任务到达时，任务可以不需要等待线程创建就能立即执行。
		3.提高线程的可管理性，使用线程池可以对线程进行统一的分配，调优和监控
4. 线程池的创建方式：
		new ThreadPoolExecutor();
5. 七大参数：
		int corePoolSize:核心线程数
        int maximumPoolSize:线程池最大容量
        long keepAliveTime:非核心线程保留时间
        TimeUnit unit:时间类型
        BlockingQueue<Runnable> workQueue:工作队列
        ThreadFactory threadFactory:线程工厂
        RejectedExecutionHandler handler:拒绝策略
6. 工作原理：
		任务进来时，首先执行判断，判断核心线程是否处于空闲状态，如果不是，核心线程就先就执行任务，如果核心线程已满，则判断任务队列是否有地方存放该任务，若果有，就将任务保存在任务队列中，等待执行，如果满了，在判断最大可容纳的线程数，如果没有超出这个数量，就开创非核心线程执行任务，如果超出了，就调用handler实现拒绝策略。
		
7. 拒绝策略
		第一种AbortPolicy:不执行新任务，直接抛出异常，提示线程池已满
        第二种DisCardPolicy:不执行新任务，也不抛出异常
        第三种DisCardOldSetPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行
        第四种CallerRunsPolicy:直接调用execute来执行当前任务
		
8. 线程池类型
        CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。
        SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。
        SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。
        FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程
        workStealingPool:如果一个线程任务执行完毕进入空闲时期时，它会从其他队列里获取任务
```



## Java中如何获取到线程dump文件

```markdown
1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java
2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid
```

