# RocketMQ

工作流程

```
1.启动时会将mq的broker,producer,consumer注册到nameserver里
2.生产者会先从nameserver中获取broker信息，然后将消息发送到对应的broker中，broker会返回接收消息的回执给生产者
3.消费者消费消息有两种一种是broker主动推送到消费者，一种是消费者从nameserver中获取对应的broker信息，然后主动拉取broker中的消息
4.而整体架构中各个服务器的健康问题都有一个监视器进行监视，并且整个架构中的服务器每个一段时间会主动向命名服务器中发送请求
```

消息丢失

```markdown
1. 生产者：
		事务消息
2. broker：
		1.通过持久化机制将消息支持持久化到Commitlog里面，即使宕机后重启，未消费的消息也是可以加载出来的
		2.使用刷盘机制，mq支持同步刷盘，异步刷盘
            同步刷盘：数据安全性较高，io次数多，效率低，速度慢。（适用于数据安全性较高的业务）
            异步输盘：数据安全性较低，io次数少，所以效率高，速度快。（适用于追求高效率处理数据的业务）
3. 消费者：
		重试机制，默认16失败后会将此消息放入死信队列
```

消息重复消费

```
在消息生产时，我们可以生成一个全局的消息ID
消费时利用redis进行一个消息的去重判断: 
    1. 判断redis中是否已经存在该消息的处理记录
    2. 不存在: 处理消息  处理完毕后将该消息全局作为key 存储在redis中
    3. 存在: 重复消息 不需要处理
```

消息堆积

