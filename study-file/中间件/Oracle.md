# Oracle

oracle采用并行服务器模式，当一个查询进来时会将当前查询分解成多个子查询，再通过CPU进行分片并行处理，提高单台服务器的性能。

#### 数据库隔离级别（采取不同的锁类型来实现）：

```markdown
1.读未提交(Read Uncommitted)：
	一个事务还没提交时，它做的变更就能被别的事务看到。解决更新丢失问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。

2.读已提交(Read Committed)：
	一个事务提交之后，它做的变更才会被其他事务看到。解决了脏读。读取数据的事务允许其他事务继续访问（访问指读和写）该行数据，但是未提交的写事务将会禁止其他事务访问该行。

3.可重复读取(Repeatable Read)：
	可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。解决了不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。

4.串行化(Serializable)：
	对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。解决了幻读的提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。
```

> oracle默认的数据库隔离级别为Read Committed（读取提交内容）。
>
> MySQL的默认事务隔离级别Repeatable Read（可重读）。





#### 线程并发所产生的问题

在并发操作同一条记录时，如果数据库隔离级别不够的话会出现并发问题，例如：

```markdown
脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
	一个事务读取到了另一个事务修改后的内容。

不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
	一个事务前后读取的数据内容不一致。

幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
	一个事务前后读取的记录行数不同。
```





